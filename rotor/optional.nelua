## local make_optional = generalize(function(T)
   local T = @#[T]#

   local OptionalT <codename #['Optional_'..T.codename]#> = @record{
      value: T,
      filled: boolean
   }

   ## OptionalT.value.is_optional = true
   ## OptionalT.value.subtype = T

   function OptionalT:get(): T
      assert(self.filled, "optional value has no value")
      return self.value
   end

   function OptionalT:set(v: T)
      self.value = v
      self.filled = true
   end

   function OptionalT:clear()
      self.value = (@T)()
      self.filled = false
   end

   ## return OptionalT
## end)

global optional: type = #[make_optional]#

## if true then
   local R = @record{v: integer}
   local optR: optional(R);

   assert(not optR.filled, "test error: optR is marked as filled, but it's with no value")

   local r = (@R){v = 123}
   optR:set(r)

   assert(optR.filled, "test error: optR is marked as not filled, but it's with value")
   assert(optR:get().v == r.v and optR.value.v == r.v, "test error: optR's value is diffent from original value")

   local x: optional(uinteger)

   assert(x.value == 0 and not x.filled, 'test error: x should be {value = 0, filled = false}')

   x:set(10)

   assert(x.value == 10 and x.filled, 'test error: x should be {value = 10, filled = true}')
   assert(x.value == x:get(), "test error: x:get() should returns the x's value")
## end
